/**
 * ä½ç½®æœåŠ¡ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * å¿«é€Ÿå®šä½ + ç¼“å­˜ + ä½ç½®ç›‘å¬
 */

import { geoLocationManager } from '@kit.LocationKit'
import { abilityAccessCtrl, common, Permissions } from '@kit.AbilityKit'

/**
 * ä½ç½®ä¿¡æ¯æ¥å£
 */
export interface LocationInfo {
  latitude: number
  longitude: number
  city: string
  address: string
}

/**
 * åœ°å€ä¿¡æ¯æ¥å£ï¼ˆç”¨äºå¼‚æ­¥è·å–åœ°å€ï¼‰
 */
interface AddressInfo {
  city: string
  address: string
}

/**
 * ä½ç½®å˜åŒ–å›è°ƒç±»å‹
 */
export type LocationChangeCallback = (location: LocationInfo) => void

/**
 * ä½ç½®æœåŠ¡ç±»ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 */
export class LocationService {
  private static instance: LocationService | null = null
  private context: common.UIAbilityContext | null = null
  
  // ç¼“å­˜ç›¸å…³
  private cachedLocation: LocationInfo | null = null
  private cacheTimestamp: number = 0
  private readonly CACHE_VALID_MS: number = 5 * 60 * 1000  // ç¼“å­˜æœ‰æ•ˆæœŸ 5 åˆ†é’Ÿ
  
  // ä½ç½®ç›‘å¬ç›¸å…³
  private isListening: boolean = false
  private locationCallbacks: LocationChangeCallback[] = []

  private constructor() {
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): LocationService {
    if (LocationService.instance === null) {
      LocationService.instance = new LocationService()
    }
    return LocationService.instance
  }

  /**
   * è®¾ç½®ä¸Šä¸‹æ–‡
   */
  setContext(context: common.UIAbilityContext): void {
    this.context = context
  }

  /**
   * æ£€æŸ¥å¹¶è¯·æ±‚ä½ç½®æƒé™
   */
  async checkAndRequestPermission(): Promise<boolean> {
    if (this.context === null) {
      console.error('[LocationService] Context not set')
      return false
    }

    const permissions: Permissions[] = [
      'ohos.permission.LOCATION',
      'ohos.permission.APPROXIMATELY_LOCATION'
    ]

    try {
      const atManager = abilityAccessCtrl.createAtManager()

      // æ£€æŸ¥æƒé™çŠ¶æ€
      const checkResult = await atManager.checkAccessToken(
        this.context.applicationInfo.accessTokenId,
        permissions[0]
      )

      if (checkResult === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
        console.info('[LocationService] å·²æœ‰ä½ç½®æƒé™')
        // æœ‰æƒé™åå¯åŠ¨ä½ç½®ç›‘å¬
        this.startLocationListener()
        return true
      }

      // è¯·æ±‚æƒé™
      console.info('[LocationService] è¯·æ±‚ä½ç½®æƒé™...')
      const requestResult = await atManager.requestPermissionsFromUser(this.context, permissions)

      const granted = requestResult.authResults.every(result =>
        result === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED
      )

      console.info('[LocationService] æƒé™è¯·æ±‚ç»“æœ: ' + granted)
      
      // æˆæƒæˆåŠŸåå¯åŠ¨ä½ç½®ç›‘å¬
      if (granted) {
        this.startLocationListener()
      }
      
      return granted
    } catch (error) {
      console.error('[LocationService] æƒé™æ£€æŸ¥å¤±è´¥: ' + JSON.stringify(error))
      return false
    }
  }

  /**
   * å¿«é€Ÿè·å–ä½ç½®ï¼ˆä¼˜å…ˆè¿”å›ç¼“å­˜ï¼Œåå°æ›´æ–°ï¼‰
   * é€‚ç”¨äºï¼šåº”ç”¨å¯åŠ¨ã€åˆ‡æ¢é¡µé¢ç­‰éœ€è¦å¿«é€Ÿå“åº”çš„åœºæ™¯
   */
  async getQuickLocation(): Promise<LocationInfo | null> {
    const startTime = Date.now()
    
    // 1. ä¼˜å…ˆè¿”å›æœ‰æ•ˆç¼“å­˜ï¼ˆæ¯«ç§’çº§å“åº”ï¼‰
    if (this.isCacheValid()) {
      console.info(`[LocationService] âš¡ ä½¿ç”¨ç¼“å­˜ä½ç½® (${Date.now() - startTime}ms)`)
      // åå°é™é»˜æ›´æ–°ä½ç½®
      this.updateLocationInBackground()
      return this.cachedLocation
    }

    // 2. å°è¯•è·å–æœ€åå·²çŸ¥ä½ç½®ï¼ˆé€šå¸¸ <100msï¼‰
    const lastLocation = await this.getLastKnownLocation()
    if (lastLocation) {
      const locationInfo = await this.buildLocationInfoQuick(lastLocation)
      this.updateCache(locationInfo)
      console.info(`[LocationService] âš¡ ä½¿ç”¨æœ€åä½ç½® (${Date.now() - startTime}ms)`)
      // åå°é™é»˜æ›´æ–°
      this.updateLocationInBackground()
      return locationInfo
    }

    // 3. å¿«é€Ÿå®šä½ï¼ˆåŸºç«™ä¼˜å…ˆï¼Œ2ç§’è¶…æ—¶ï¼‰
    console.info('[LocationService] å¿«é€Ÿå®šä½...')
    const quickLocation = await this.tryGetLocation('QUICK', {
      priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
      scenario: geoLocationManager.LocationRequestScenario.UNSET,
      maxAccuracy: 1000,  // æ”¾å®½ç²¾åº¦è¦æ±‚
      timeoutMs: 2000     // 2ç§’è¶…æ—¶
    })
    
    if (quickLocation) {
      const locationInfo = await this.buildLocationInfoQuick(quickLocation)
      this.updateCache(locationInfo)
      console.info(`[LocationService] âš¡ å¿«é€Ÿå®šä½æˆåŠŸ (${Date.now() - startTime}ms)`)
      // åå°è·å–æ›´ç²¾ç¡®ä½ç½®
      this.updateLocationInBackground()
      return locationInfo
    }

    // 4. æ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥ï¼Œè¿”å›é»˜è®¤ä½ç½®
    console.warn(`[LocationService] å¿«é€Ÿå®šä½å¤±è´¥ï¼Œè¿”å›é»˜è®¤ä½ç½® (${Date.now() - startTime}ms)`)
    return this.getDefaultLocation()
  }

  /**
   * ç²¾ç¡®è·å–ä½ç½®ï¼ˆç­‰å¾… GPSï¼‰
   * é€‚ç”¨äºï¼šç”¨æˆ·ç‚¹å‡»å®šä½æŒ‰é’®ç­‰éœ€è¦ç²¾ç¡®ä½ç½®çš„åœºæ™¯
   */
  async getCurrentLocation(): Promise<LocationInfo | null> {
    const startTime = Date.now()
    
    try {
      // æ£€æŸ¥ä½ç½®æœåŠ¡æ˜¯å¦å¯ç”¨
      const isEnabled = geoLocationManager.isLocationEnabled()
      if (!isEnabled) {
        console.error('[LocationService] ä½ç½®æœåŠ¡æœªå¯ç”¨')
        return this.cachedLocation || this.getDefaultLocation()
      }

      // ç­–ç•¥1: å…ˆå°è¯•å¿«é€Ÿå®šä½ï¼ˆåŸºç«™/ç½‘ç»œï¼Œ2ç§’ï¼‰
      console.info('[LocationService] å°è¯•å¿«é€Ÿå®šä½...')
      const quickLocation = await this.tryGetLocation('QUICK', {
        priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        maxAccuracy: 500,
        timeoutMs: 2000
      })
      
      if (quickLocation) {
        const locationInfo = await this.buildLocationInfo(quickLocation)
        this.updateCache(locationInfo)
        console.info(`[LocationService] âœ… å¿«é€Ÿå®šä½æˆåŠŸ (${Date.now() - startTime}ms)`)
        
        // åå°ç»§ç»­ GPS ç²¾ç¡®å®šä½
        this.getGpsLocationInBackground()
        return locationInfo
      }

      // ç­–ç•¥2: GPS ç²¾ç¡®å®šä½ï¼ˆ3ç§’è¶…æ—¶ï¼‰
      console.info('[LocationService] å°è¯• GPS å®šä½...')
      const gpsLocation = await this.tryGetLocation('GPS', {
        priority: geoLocationManager.LocationRequestPriority.ACCURACY,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        maxAccuracy: 100,
        timeoutMs: 3000
      })
      
      if (gpsLocation) {
        const locationInfo = await this.buildLocationInfo(gpsLocation)
        this.updateCache(locationInfo)
        console.info(`[LocationService] âœ… GPS å®šä½æˆåŠŸ (${Date.now() - startTime}ms)`)
        return locationInfo
      }

      // ç­–ç•¥3: ä½¿ç”¨æœ€åä¸€æ¬¡å®šä½
      const lastLocation = await this.getLastKnownLocation()
      if (lastLocation) {
        const locationInfo = await this.buildLocationInfo(lastLocation)
        this.updateCache(locationInfo)
        console.info(`[LocationService] âœ… ä½¿ç”¨æœ€åä½ç½® (${Date.now() - startTime}ms)`)
        return locationInfo
      }

      // ç­–ç•¥4: è¿”å›ç¼“å­˜
      if (this.cachedLocation) {
        console.info(`[LocationService] âœ… ä½¿ç”¨ç¼“å­˜ä½ç½® (${Date.now() - startTime}ms)`)
        return this.cachedLocation
      }

      console.error(`[LocationService] âŒ æ‰€æœ‰å®šä½ç­–ç•¥å‡å¤±è´¥ (${Date.now() - startTime}ms)`)
      return this.getDefaultLocation()
    } catch (error) {
      console.error('[LocationService] è·å–ä½ç½®å¤±è´¥: ' + JSON.stringify(error))
      return this.cachedLocation || this.getDefaultLocation()
    }
  }

  /**
   * åå°é™é»˜æ›´æ–°ä½ç½®ï¼ˆä¸é˜»å¡ UIï¼‰
   */
  private updateLocationInBackground(): void {
    setTimeout(async () => {
      try {
        const location = await this.tryGetLocation('BG_GPS', {
          priority: geoLocationManager.LocationRequestPriority.ACCURACY,
          scenario: geoLocationManager.LocationRequestScenario.UNSET,
          maxAccuracy: 100,
          timeoutMs: 5000
        })
        
        if (location) {
          const locationInfo = await this.buildLocationInfo(location)
          this.updateCache(locationInfo)
          // é€šçŸ¥è®¢é˜…è€…ä½ç½®æ›´æ–°
          this.notifyLocationChange(locationInfo)
          console.info('[LocationService] ğŸ”„ åå°ä½ç½®å·²æ›´æ–°')
        }
      } catch (e) {
        console.warn('[LocationService] åå°æ›´æ–°ä½ç½®å¤±è´¥')
      }
    }, 100)
  }

  /**
   * åå°è·å– GPS ç²¾ç¡®ä½ç½®
   */
  private getGpsLocationInBackground(): void {
    setTimeout(async () => {
      try {
        const location = await this.tryGetLocation('BG_GPS', {
          priority: geoLocationManager.LocationRequestPriority.ACCURACY,
          scenario: geoLocationManager.LocationRequestScenario.UNSET,
          maxAccuracy: 50,
          timeoutMs: 8000
        })
        
        if (location) {
          const locationInfo = await this.buildLocationInfo(location)
          
          // åªæœ‰æ›´ç²¾ç¡®æ—¶æ‰æ›´æ–°
          if (this.cachedLocation) {
            const distance = this.calculateDistance(
              this.cachedLocation.latitude, this.cachedLocation.longitude,
              locationInfo.latitude, locationInfo.longitude
            )
            if (distance > 50) {  // åå·®è¶…è¿‡ 50 ç±³æ‰æ›´æ–°
              this.updateCache(locationInfo)
              this.notifyLocationChange(locationInfo)
              console.info(`[LocationService] ğŸ¯ GPS ç²¾ç¡®ä½ç½®å·²æ›´æ–°ï¼ˆåå·® ${distance.toFixed(0)}mï¼‰`)
            }
          } else {
            this.updateCache(locationInfo)
            this.notifyLocationChange(locationInfo)
          }
        }
      } catch (e) {
        console.warn('[LocationService] åå° GPS å®šä½å¤±è´¥')
      }
    }, 100)
  }

  /**
   * å¯åŠ¨ä½ç½®ç›‘å¬ï¼ˆæˆæƒåè‡ªåŠ¨æ›´æ–°ä½ç½®ï¼‰
   */
  startLocationListener(): void {
    if (this.isListening) {
      return
    }
    
    try {
      const locationRequest: geoLocationManager.LocationRequest = {
        priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        timeInterval: 60,      // 60ç§’æ›´æ–°ä¸€æ¬¡
        distanceInterval: 100, // ç§»åŠ¨ 100 ç±³æ›´æ–°ä¸€æ¬¡
        maxAccuracy: 200
      }
      
      geoLocationManager.on('locationChange', locationRequest, async (location) => {
        console.info(`[LocationService] ğŸ“ ä½ç½®å˜åŒ–: ${location.latitude}, ${location.longitude}`)
        const locationInfo = await this.buildLocationInfoQuick(location)
        this.updateCache(locationInfo)
        this.notifyLocationChange(locationInfo)
      })
      
      this.isListening = true
      console.info('[LocationService] âœ… ä½ç½®ç›‘å¬å·²å¯åŠ¨')
    } catch (e) {
      console.warn('[LocationService] å¯åŠ¨ä½ç½®ç›‘å¬å¤±è´¥: ' + JSON.stringify(e))
    }
  }

  /**
   * åœæ­¢ä½ç½®ç›‘å¬
   */
  stopLocationListener(): void {
    if (!this.isListening) {
      return
    }
    
    try {
      geoLocationManager.off('locationChange')
      this.isListening = false
      console.info('[LocationService] ä½ç½®ç›‘å¬å·²åœæ­¢')
    } catch (e) {
      console.warn('[LocationService] åœæ­¢ä½ç½®ç›‘å¬å¤±è´¥')
    }
  }

  /**
   * è®¢é˜…ä½ç½®å˜åŒ–
   */
  onLocationChange(callback: LocationChangeCallback): void {
    this.locationCallbacks.push(callback)
  }

  /**
   * å–æ¶ˆè®¢é˜…
   */
  offLocationChange(callback: LocationChangeCallback): void {
    const index = this.locationCallbacks.indexOf(callback)
    if (index > -1) {
      this.locationCallbacks.splice(index, 1)
    }
  }

  /**
   * é€šçŸ¥ä½ç½®å˜åŒ–
   */
  private notifyLocationChange(location: LocationInfo): void {
    for (let i = 0; i < this.locationCallbacks.length; i++) {
      try {
        this.locationCallbacks[i](location)
      } catch (e) {
        console.warn('[LocationService] å›è°ƒæ‰§è¡Œå¤±è´¥')
      }
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
   */
  private isCacheValid(): boolean {
    if (!this.cachedLocation) {
      return false
    }
    return Date.now() - this.cacheTimestamp < this.CACHE_VALID_MS
  }

  /**
   * æ›´æ–°ç¼“å­˜
   */
  private updateCache(location: LocationInfo): void {
    this.cachedLocation = location
    this.cacheTimestamp = Date.now()
  }

  /**
   * å°è¯•å•æ¬¡å®šä½
   */
  private async tryGetLocation(
    type: string,
    request: geoLocationManager.CurrentLocationRequest
  ): Promise<geoLocationManager.Location | null> {
    try {
      const location = await geoLocationManager.getCurrentLocation(request)
      console.info(`[LocationService] ${type} å®šä½: ${location.latitude}, ${location.longitude}`)
      return location
    } catch (error) {
      console.warn(`[LocationService] ${type} å®šä½å¤±è´¥: ${JSON.stringify(error)}`)
      return null
    }
  }

  /**
   * è·å–æœ€åå·²çŸ¥ä½ç½®
   */
  private async getLastKnownLocation(): Promise<geoLocationManager.Location | null> {
    try {
      const location = await geoLocationManager.getLastLocation()
      if (location) {
        console.info(`[LocationService] æœ€åä½ç½®: ${location.latitude}, ${location.longitude}`)
        return location
      }
      return null
    } catch (error) {
      console.warn('[LocationService] è·å–æœ€åä½ç½®å¤±è´¥: ' + JSON.stringify(error))
      return null
    }
  }

  /**
   * å¿«é€Ÿæ„å»ºä½ç½®ä¿¡æ¯ï¼ˆå¼‚æ­¥è·å–åŸå¸‚åï¼Œä¸é˜»å¡ï¼‰
   */
  private async buildLocationInfoQuick(location: geoLocationManager.Location): Promise<LocationInfo> {
    const locationInfo: LocationInfo = {
      latitude: location.latitude,
      longitude: location.longitude,
      city: 'å½“å‰ä½ç½®',  // å…ˆç”¨é»˜è®¤å€¼
      address: ''
    }

    // å¼‚æ­¥è·å–åŸå¸‚åï¼ˆä¸é˜»å¡è¿”å›ï¼‰
    this.getAddressAsync(location.latitude, location.longitude).then((address) => {
      if (address && this.cachedLocation) {
        this.cachedLocation.city = address.city
        this.cachedLocation.address = address.address
        // é€šçŸ¥åŸå¸‚åå·²æ›´æ–°
        this.notifyLocationChange(this.cachedLocation)
      }
    })

    return locationInfo
  }

  /**
   * æ„å»ºä½ç½®ä¿¡æ¯ï¼ˆåŒ…å«é€†åœ°ç†ç¼–ç ï¼Œä¼šç­‰å¾…ï¼‰
   */
  private async buildLocationInfo(location: geoLocationManager.Location): Promise<LocationInfo> {
    const locationInfo: LocationInfo = {
      latitude: location.latitude,
      longitude: location.longitude,
      city: '',
      address: ''
    }

    // å°è¯•é€†åœ°ç†ç¼–ç è·å–åŸå¸‚åï¼ˆæœ€å¤šç­‰å¾… 2 ç§’ï¼‰
    try {
      const addressPromise = this.getAddressAsync(location.latitude, location.longitude)
      const timeoutPromise = new Promise<null>((resolve) => setTimeout(() => resolve(null), 2000))
      
      const address = await Promise.race([addressPromise, timeoutPromise])
      if (address) {
        locationInfo.city = address.city
        locationInfo.address = address.address
      } else {
        locationInfo.city = 'å½“å‰ä½ç½®'
      }
    } catch (geoError) {
      console.warn('[LocationService] é€†åœ°ç†ç¼–ç å¤±è´¥: ' + JSON.stringify(geoError))
      locationInfo.city = 'å½“å‰ä½ç½®'
    }

    return locationInfo
  }

  /**
   * å¼‚æ­¥è·å–åœ°å€
   */
  private async getAddressAsync(latitude: number, longitude: number): Promise<AddressInfo | null> {
    try {
      const reverseRequest: geoLocationManager.ReverseGeoCodeRequest = {
        latitude: latitude,
        longitude: longitude,
        maxItems: 1
      }
      const addresses = await geoLocationManager.getAddressesFromLocation(reverseRequest)
      if (addresses.length > 0) {
        const addr = addresses[0]
        const city = (addr.administrativeArea || '') + ', ' + (addr.locality || '')
        const address = addr.placeName || ''
        console.info('[LocationService] åŸå¸‚: ' + city)
        const addressInfo: AddressInfo = { city, address }
        return addressInfo
      }
    } catch (e) {
      console.warn('[LocationService] è·å–åœ°å€å¤±è´¥')
    }
    return null
  }

  /**
   * è®¡ç®—ä¸¤ç‚¹è·ç¦»ï¼ˆç±³ï¼‰
   */
  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
    const R = 6371000  // åœ°çƒåŠå¾„ï¼ˆç±³ï¼‰
    const dLat = (lat2 - lat1) * Math.PI / 180
    const dLng = (lng2 - lng1) * Math.PI / 180
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2)
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
    return R * c
  }

  /**
   * è·å–ç¼“å­˜çš„ä½ç½®
   */
  getCachedLocation(): LocationInfo | null {
    return this.cachedLocation
  }

  /**
   * è·å–é»˜è®¤ä½ç½®ï¼ˆå¹¿å·ï¼‰
   */
  getDefaultLocation(): LocationInfo {
    return {
      latitude: 23.1291,
      longitude: 113.2644,
      city: 'å¹¿ä¸œçœ, å¹¿å·å¸‚',
      address: 'å¹¿å·å¸‚'
    }
  }
}


