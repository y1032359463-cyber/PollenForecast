/*
 * èŠ±ç²‰æµ“åº¦é¢„æŠ¥ï¼ˆé¸¿è’™ç‰ˆï¼‰V1.0.2 æºä»£ç 
 * å30é¡µ
 * 
 * æ ¼å¼è¦æ±‚ï¼š
 * 1. é¡µçœ‰ï¼šèŠ±ç²‰æµ“åº¦é¢„æŠ¥ï¼ˆé¸¿è’™ç‰ˆï¼‰V1.0.2 æºä»£ç 
 * 2. æ¯é¡µâ‰¥50è¡Œ
 * 3. å­—ä½“ï¼šç­‰å®½å­—ä½“ï¼ˆå¦‚ Consolasã€Source Code Proï¼‰ï¼Œ10-11pt
 * 4. è¡Œè·ï¼šå•å€è¡Œè·
 * 
 * å¯¼å‡ºPDFæ­¥éª¤ï¼š
 * 1. å°†æœ¬æ–‡æ¡£å†…å®¹ç²˜è´´åˆ° Microsoft Word
 * 2. è®¾ç½®é¡µçœ‰ï¼šæ’å…¥ -> é¡µçœ‰ -> è¾“å…¥"èŠ±ç²‰æµ“åº¦é¢„æŠ¥ï¼ˆé¸¿è’™ç‰ˆï¼‰V1.0.2 æºä»£ç "
 * 3. è®¾ç½®å­—ä½“ï¼šå…¨é€‰ -> Consolas 10ptï¼Œå•å€è¡Œè·
 * 4. è°ƒæ•´é¡µè¾¹è·å’Œè¡Œè·ï¼Œç¡®ä¿æ¯é¡µâ‰¥50è¡Œ
 * 5. æ·»åŠ é¡µç ï¼ˆç¬¬31é¡µå¼€å§‹ï¼‰
 * 6. å¯¼å‡ºPDFï¼šæ–‡ä»¶ -> å¦å­˜ä¸º -> PDFæ ¼å¼
 */
// æ–‡ä»¶: entry/src/main/ets/service/PollenService.ets
import { http } from '@kit.NetworkKit'
import { PollenForecastResponse } from '../model/PollenModels'
import { PollenDataSourceType } from '../model/PollenDataSource'
interface ServerConfig {
  name: string
  url: string
  timeout: number
  priority: number
}
interface ServerStatus {
  lastSuccess: number
  failCount: number
  isHealthy: boolean
}
const POLLEN_SERVERS: ServerConfig[] = [
  {
    name: 'AWS Lambda ä¸œäº¬',
    url: 'https://g7d8o7pf5b.execute-api.ap-northeast-1.amazonaws.com/default/pollen-api',
    timeout: 20000,
    priority: 1
  },
  {
    name: 'AWS Lambda æ–°åŠ å¡',
    url: 'https://8de0lncs7f.execute-api.ap-southeast-1.amazonaws.com/default/pollen-api-singapore',
    timeout: 20000,
    priority: 2
  },
  {
    name: 'é˜¿é‡Œäº‘æ–°åŠ å¡',
    url: 'http://47.84.1.164:5000/pollen-api',
    timeout: 15000,
    priority: 3
  },
]
const serverStatusMap: Map<string, ServerStatus> = new Map()
const HEALTH_CHECK_INTERVAL = 5 * 60 * 1000
const MAX_FAIL_COUNT = 3
export class PollenService {
  private static instance: PollenService | null = null
  private constructor() {
    this.initServerStatus()
  }
  static getInstance(): PollenService {
    if (PollenService.instance === null) {
      PollenService.instance = new PollenService()
    }
    return PollenService.instance
  }
  private initServerStatus(): void {
    for (const server of POLLEN_SERVERS) {
      if (!serverStatusMap.has(server.url)) {
        serverStatusMap.set(server.url, {
          lastSuccess: 0,
          failCount: 0,
          isHealthy: true
        })
      }
    }
  }
  private getSortedServers(): ServerConfig[] {
    const now = Date.now()
    return POLLEN_SERVERS.slice().sort((a, b) => {
      const statusA = serverStatusMap.get(a.url)
      const statusB = serverStatusMap.get(b.url)
      if (!statusA || !statusB) return a.priority - b.priority
      if (statusA.isHealthy !== statusB.isHealthy) {
        return statusA.isHealthy ? -1 : 1
      }
      if (statusA.lastSuccess !== statusB.lastSuccess) {
        return statusB.lastSuccess - statusA.lastSuccess
      }
      return a.priority - b.priority
    })
  }
  private markServerSuccess(serverUrl: string): void {
    const status = serverStatusMap.get(serverUrl)
    if (status) {
      status.lastSuccess = Date.now()
      status.failCount = 0
      status.isHealthy = true
      console.info(`[PollenService] æœåŠ¡å™¨æˆåŠŸ: ${serverUrl}`)
    }
  }
  private markServerFail(serverUrl: string): void {
    const status = serverStatusMap.get(serverUrl)
    if (status) {
      status.failCount++
      if (status.failCount >= MAX_FAIL_COUNT) {
        status.isHealthy = false
        console.warn(`[PollenService] æœåŠ¡å™¨æ ‡è®°ä¸ºä¸å¥åº·: ${serverUrl}, è¿ç»­å¤±è´¥ ${status.failCount} æ¬¡`)
      }
    }
  }
  private shouldRetryServer(serverUrl: string): boolean {
    const status = serverStatusMap.get(serverUrl)
    if (!status) return true
    if (status.isHealthy) return true
    const timeSinceLastSuccess = Date.now() - status.lastSuccess
    return timeSinceLastSuccess > HEALTH_CHECK_INTERVAL
  }
  private async requestFromServer(
    server: ServerConfig,
    latitude: number,
    longitude: number,
    days: number
  ): Promise<PollenForecastResponse | null> {
    const url = `${server.url}?lat=${latitude}&lng=${longitude}&days=${days}`
    console.info(`[PollenService] å°è¯•æœåŠ¡å™¨ [${server.name}]: ${url}`)
    const httpRequest = http.createHttp()
    try {
      const response = await httpRequest.request(url, {
        method: http.RequestMethod.GET,
        header: {
          'Content-Type': 'application/json'
        },
        connectTimeout: server.timeout,
        readTimeout: server.timeout
      })
      console.info(`[PollenService] [${server.name}] å“åº”ç : ${response.responseCode}`)
      if (response.responseCode === 200) {
        const resultStr = response.result as string
        const result: PollenForecastResponse = JSON.parse(resultStr)
        console.info(`[PollenService] [${server.name}] è·å–æˆåŠŸ: ${result.regionCode}`)
        httpRequest.destroy()
        this.markServerSuccess(server.url)
        return result
      } else {
        console.error(`[PollenService] [${server.name}] è¯·æ±‚å¤±è´¥: ${response.responseCode}`)
        httpRequest.destroy()
        this.markServerFail(server.url)
        return null
      }
    } catch (error) {
      console.error(`[PollenService] [${server.name}] ç½‘ç»œå¼‚å¸¸: ${JSON.stringify(error)}`)
      httpRequest.destroy()
      this.markServerFail(server.url)
      return null
    }
  }
  async getPollenForecast(
    latitude: number,
    longitude: number,
    days: number = 5
  ): Promise<PollenForecastResponse | null> {
    const selectedDataSource: string = AppStorage.get('pollenDataSource') as string || 'AUTO'
    const dataSourceType = selectedDataSource as PollenDataSourceType
    console.info(`[PollenService] ç”¨æˆ·é€‰æ‹©çš„æ•°æ®æº: ${dataSourceType}`)
    switch (dataSourceType) {
      case PollenDataSourceType.AUTO:
      case PollenDataSourceType.GOOGLE:
        return await this.getPollenForecastFromGoogle(latitude, longitude, days)
      case PollenDataSourceType.CMA:
        console.warn('[PollenService] ä¸­å›½æ°”è±¡å±€æ•°æ®æºæš‚æœªå®ç°')
        return null
      case PollenDataSourceType.QWEATHER:
        console.warn('[PollenService] å’Œé£å¤©æ°”æ•°æ®æºæš‚æœªå®ç°')
        return null
      default:
        console.error(`[PollenService] æœªçŸ¥çš„æ•°æ®æºç±»å‹: ${dataSourceType}`)
        return await this.getPollenForecastFromGoogle(latitude, longitude, days)
    }
  }
  private async getPollenForecastFromGoogle(
    latitude: number,
    longitude: number,
    days: number
  ): Promise<PollenForecastResponse | null> {
    const servers = this.getSortedServers()
    console.info(`[PollenService] å¼€å§‹è¯·æ±‚ Google Pollen APIï¼Œå¯ç”¨æœåŠ¡å™¨: ${servers.length}`)
    for (const server of servers) {
      if (!this.shouldRetryServer(server.url)) {
        console.info(`[PollenService] è·³è¿‡ä¸å¥åº·æœåŠ¡å™¨: ${server.name}`)
        continue
      }
      const result = await this.requestFromServer(server, latitude, longitude, days)
      if (result !== null) {
        return result
      }
      console.warn(`[PollenService] [${server.name}] å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæœåŠ¡å™¨...`)
    }
    console.error('[PollenService] æ‰€æœ‰ Google Pollen API æœåŠ¡å™¨å‡è¯·æ±‚å¤±è´¥')
    return null
  }
  getServerStatus(): string {
    const statusList: string[] = []
    for (const server of POLLEN_SERVERS) {
      const status = serverStatusMap.get(server.url)
      if (status) {
        statusList.push(
          `${server.name}: ${status.isHealthy ? 'âœ…å¥åº·' : 'âŒä¸å¥åº·'} (å¤±è´¥${status.failCount}æ¬¡)`
        )
      }
    }
    return statusList.join(', ')
  }
  resetServerStatus(): void {
    for (const server of POLLEN_SERVERS) {
      serverStatusMap.set(server.url, {
        lastSuccess: 0,
        failCount: 0,
        isHealthy: true
      })
    }
    console.info('[PollenService] æ‰€æœ‰æœåŠ¡å™¨çŠ¶æ€å·²é‡ç½®')
  }
}
// æ–‡ä»¶: entry/src/main/ets/service/WeatherService.ets
import { http } from '@kit.NetworkKit'
const WEATHER_PROXY_BASE = 'http://106.12.143.105:3000'
export interface WeatherResponse {
  temperature: number
  feelsLike: number
  humidity: number
  pressure: number
  windSpeed: number
  windDirection: string
  sunrise: string
  sunset: string
  description: string
  tempMax?: number
  tempMin?: number
}
interface QWeatherNow {
  temp: string
  feelsLike: string
  humidity: string
  pressure: string
  windSpeed: string
  windDir: string
  text: string
}
interface QWeatherNowResponse {
  code?: string
  now?: QWeatherNow
  updateTime?: string
}
interface QWeatherSunResponse {
  code?: string
  sunrise?: string
  sunset?: string
}
interface QWeatherDaily {
  tempMax: string
  tempMin: string
}
interface QWeatherDailyResponse {
  code?: string
  daily?: QWeatherDaily[]
}
export class WeatherService {
  private static instance: WeatherService | null = null
  private constructor() {
  }
  static getInstance(): WeatherService {
    if (WeatherService.instance === null) {
      WeatherService.instance = new WeatherService()
    }
    return WeatherService.instance
  }
  async getWeather(
    latitude: number,
    longitude: number
  ): Promise<WeatherResponse | null> {
    try {
      const location = `${longitude.toFixed(2)},${latitude.toFixed(2)}`
      const today = this.getTodayDate()
      const weatherUrl = `${WEATHER_PROXY_BASE}/weather/now?location=${location}`
      const sunUrl = `${WEATHER_PROXY_BASE}/astronomy/sun?location=${location}&date=${today}`
      const dailyUrl = `${WEATHER_PROXY_BASE}/weather/7d?location=${location}`
      console.info('[WeatherService] è¯·æ±‚å®æ—¶å¤©æ°”: ' + weatherUrl)
      console.info('[WeatherService] è¯·æ±‚å¤©æ–‡æ•°æ®: ' + sunUrl)
      console.info('[WeatherService] è¯·æ±‚æ¯æ—¥é¢„æŠ¥: ' + dailyUrl)
      const weatherRes = await this.requestQWeather<QWeatherNowResponse>(weatherUrl)
      const sunRes = await this.requestQWeather<QWeatherSunResponse>(sunUrl)
      const dailyRes = await this.requestQWeather<QWeatherDailyResponse>(dailyUrl)
      if (weatherRes === null || weatherRes.code === undefined || weatherRes.now === undefined) {
        console.error('[WeatherService] å¤©æ°”æ•°æ®æ— æ•ˆ')
        return null
      }
      if (weatherRes.code !== '200') {
        console.error('[WeatherService] å’Œé£å¤©æ°”è¿”å›é”™è¯¯ç : ' + weatherRes.code)
        return null
      }
      let sunrise = '06:00'
      let sunset = '18:00'
      if (sunRes !== null && sunRes.code !== undefined && sunRes.sunrise !== undefined) {
        if (sunRes.code === '200') {
          sunrise = this.extractTime(sunRes.sunrise)
          sunset = this.extractTime(sunRes.sunset || '18:00')
        }
      }
      let tempMax: number | undefined = undefined
      let tempMin: number | undefined = undefined
      if (dailyRes !== null && dailyRes.code === '200' && dailyRes.daily !== undefined && dailyRes.daily.length > 0) {
        const todayForecast = dailyRes.daily[0]
        tempMax = parseFloat(todayForecast.tempMax)
        tempMin = parseFloat(todayForecast.tempMin)
        console.info(`[WeatherService] ä»Šæ—¥æ¸©åº¦: æœ€é«˜${tempMax}Â°C, æœ€ä½${tempMin}Â°C`)
      }
      const result: WeatherResponse = {
        temperature: parseFloat(weatherRes.now.temp),
        feelsLike: parseFloat(weatherRes.now.feelsLike),
        humidity: parseFloat(weatherRes.now.humidity),
        pressure: parseFloat(weatherRes.now.pressure),
        windSpeed: parseFloat(weatherRes.now.windSpeed),
        windDirection: weatherRes.now.windDir,
        sunrise: sunrise,
        sunset: sunset,
        description: weatherRes.now.text,
        tempMax: tempMax,
        tempMin: tempMin
      }
      console.info('[WeatherService] å¤©æ°”æ•°æ®è·å–æˆåŠŸ: ' + result.description)
      return result
    } catch (error) {
      console.error('[WeatherService] å¤©æ°”è·å–å¼‚å¸¸: ' + JSON.stringify(error))
      return null
    }
  }
  private async requestQWeather<T>(url: string): Promise<T | null> {
    const httpRequest = http.createHttp()
    try {
      const response = await httpRequest.request(url, {
        method: http.RequestMethod.GET,
        header: {
          'Content-Type': 'application/json'
        },
        connectTimeout: 10000,
        readTimeout: 10000
      })
      httpRequest.destroy()
      if (response.responseCode === 200) {
        const resultStr = response.result as string
        return JSON.parse(resultStr) as T
      } else {
        console.error('[WeatherService] HTTP è¯·æ±‚å¤±è´¥: ' + response.responseCode)
        return null
      }
    } catch (error) {
      httpRequest.destroy()
      console.error('[WeatherService] è¯·æ±‚å¼‚å¸¸: ' + JSON.stringify(error))
      return null
    }
  }
  private getTodayDate(): string {
    const now = new Date()
    const year = now.getFullYear()
    const month = String(now.getMonth() + 1).padStart(2, '0')
    const day = String(now.getDate()).padStart(2, '0')
    return `${year}${month}${day}`
  }
  private extractTime(isoTime: string): string {
    try {
      const match = isoTime.match(/T(\d{2}:\d{2})/)
      if (match !== null && match[1] !== undefined) {
        return match[1]
      }
      return isoTime
    } catch (error) {
      console.error('[WeatherService] æ—¶é—´è§£æå¤±è´¥: ' + isoTime)
      return '00:00'
    }
  }
}
// æ–‡ä»¶: entry/src/main/ets/service/LocationService.ets
import { geoLocationManager } from '@kit.LocationKit'
import { abilityAccessCtrl, common, Permissions } from '@kit.AbilityKit'
export interface LocationInfo {
  latitude: number
  longitude: number
  city: string
  address: string
}
export type LocationChangeCallback = (location: LocationInfo) => void
export class LocationService {
  private static instance: LocationService | null = null
  private context: common.UIAbilityContext | null = null
  private cachedLocation: LocationInfo | null = null
  private cacheTimestamp: number = 0
  private readonly CACHE_VALID_MS: number = 5 * 60 * 1000
  private isListening: boolean = false
  private locationCallbacks: LocationChangeCallback[] = []
  private constructor() {
  }
  static getInstance(): LocationService {
    if (LocationService.instance === null) {
      LocationService.instance = new LocationService()
    }
    return LocationService.instance
  }
  setContext(context: common.UIAbilityContext): void {
    this.context = context
  }
  async checkAndRequestPermission(): Promise<boolean> {
    if (this.context === null) {
      console.error('[LocationService] Context not set')
      return false
    }
    const permissions: Permissions[] = [
      'ohos.permission.LOCATION',
      'ohos.permission.APPROXIMATELY_LOCATION'
    ]
    try {
      const atManager = abilityAccessCtrl.createAtManager()
      const checkResult = await atManager.checkAccessToken(
        this.context.applicationInfo.accessTokenId,
        permissions[0]
      )
      if (checkResult === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED) {
        console.info('[LocationService] å·²æœ‰ä½ç½®æƒé™')
        this.startLocationListener()
        return true
      }
      console.info('[LocationService] è¯·æ±‚ä½ç½®æƒé™...')
      const requestResult = await atManager.requestPermissionsFromUser(this.context, permissions)
      const granted = requestResult.authResults.every(result =>
        result === abilityAccessCtrl.GrantStatus.PERMISSION_GRANTED
      )
      console.info('[LocationService] æƒé™è¯·æ±‚ç»“æœ: ' + granted)
      if (granted) {
        this.startLocationListener()
      }
      return granted
    } catch (error) {
      console.error('[LocationService] æƒé™æ£€æŸ¥å¤±è´¥: ' + JSON.stringify(error))
      return false
    }
  }
  async getQuickLocation(): Promise<LocationInfo | null> {
    const startTime = Date.now()
    if (this.isCacheValid()) {
      console.info(`[LocationService] âš¡ ä½¿ç”¨ç¼“å­˜ä½ç½® (${Date.now() - startTime}ms)`)
      this.updateLocationInBackground()
      return this.cachedLocation
    }
    const lastLocation = await this.getLastKnownLocation()
    if (lastLocation) {
      const locationInfo = await this.buildLocationInfoQuick(lastLocation)
      this.updateCache(locationInfo)
      console.info(`[LocationService] âš¡ ä½¿ç”¨æœ€åä½ç½® (${Date.now() - startTime}ms)`)
      this.updateLocationInBackground()
      return locationInfo
    }
    console.info('[LocationService] å¿«é€Ÿå®šä½...')
    const quickLocation = await this.tryGetLocation('QUICK', {
      priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
      scenario: geoLocationManager.LocationRequestScenario.UNSET,
      maxAccuracy: 1000,
      timeoutMs: 2000
    })
    if (quickLocation) {
      const locationInfo = await this.buildLocationInfoQuick(quickLocation)
      this.updateCache(locationInfo)
      console.info(`[LocationService] âš¡ å¿«é€Ÿå®šä½æˆåŠŸ (${Date.now() - startTime}ms)`)
      this.updateLocationInBackground()
      return locationInfo
    }
    console.warn(`[LocationService] å¿«é€Ÿå®šä½å¤±è´¥ï¼Œè¿”å›é»˜è®¤ä½ç½® (${Date.now() - startTime}ms)`)
    return this.getDefaultLocation()
  }
  async getCurrentLocation(): Promise<LocationInfo | null> {
    const startTime = Date.now()
    try {
      const isEnabled = geoLocationManager.isLocationEnabled()
      if (!isEnabled) {
        console.error('[LocationService] ä½ç½®æœåŠ¡æœªå¯ç”¨')
        return this.cachedLocation || this.getDefaultLocation()
      }
      console.info('[LocationService] å°è¯•å¿«é€Ÿå®šä½...')
      const quickLocation = await this.tryGetLocation('QUICK', {
        priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        maxAccuracy: 500,
        timeoutMs: 2000
      })
      if (quickLocation) {
        const locationInfo = await this.buildLocationInfo(quickLocation)
        this.updateCache(locationInfo)
        console.info(`[LocationService] âœ… å¿«é€Ÿå®šä½æˆåŠŸ (${Date.now() - startTime}ms)`)
        this.getGpsLocationInBackground()
        return locationInfo
      }
      console.info('[LocationService] å°è¯• GPS å®šä½...')
      const gpsLocation = await this.tryGetLocation('GPS', {
        priority: geoLocationManager.LocationRequestPriority.ACCURACY,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        maxAccuracy: 100,
        timeoutMs: 3000
      })
      if (gpsLocation) {
        const locationInfo = await this.buildLocationInfo(gpsLocation)
        this.updateCache(locationInfo)
        console.info(`[LocationService] âœ… GPS å®šä½æˆåŠŸ (${Date.now() - startTime}ms)`)
        return locationInfo
      }
      const lastLocation = await this.getLastKnownLocation()
      if (lastLocation) {
        const locationInfo = await this.buildLocationInfo(lastLocation)
        this.updateCache(locationInfo)
        console.info(`[LocationService] âœ… ä½¿ç”¨æœ€åä½ç½® (${Date.now() - startTime}ms)`)
        return locationInfo
      }
      if (this.cachedLocation) {
        console.info(`[LocationService] âœ… ä½¿ç”¨ç¼“å­˜ä½ç½® (${Date.now() - startTime}ms)`)
        return this.cachedLocation
      }
      console.error(`[LocationService] âŒ æ‰€æœ‰å®šä½ç­–ç•¥å‡å¤±è´¥ (${Date.now() - startTime}ms)`)
      return this.getDefaultLocation()
    } catch (error) {
      console.error('[LocationService] è·å–ä½ç½®å¤±è´¥: ' + JSON.stringify(error))
      return this.cachedLocation || this.getDefaultLocation()
    }
  }
  private updateLocationInBackground(): void {
    setTimeout(async () => {
      try {
        const location = await this.tryGetLocation('BG_GPS', {
          priority: geoLocationManager.LocationRequestPriority.ACCURACY,
          scenario: geoLocationManager.LocationRequestScenario.UNSET,
          maxAccuracy: 100,
          timeoutMs: 5000
        })
        if (location) {
          const locationInfo = await this.buildLocationInfo(location)
          this.updateCache(locationInfo)
          this.notifyLocationChange(locationInfo)
          console.info('[LocationService] ğŸ”„ åå°ä½ç½®å·²æ›´æ–°')
        }
      } catch (e) {
        console.warn('[LocationService] åå°æ›´æ–°ä½ç½®å¤±è´¥')
      }
    }, 100)
  }
  private getGpsLocationInBackground(): void {
    setTimeout(async () => {
      try {
        const location = await this.tryGetLocation('BG_GPS', {
          priority: geoLocationManager.LocationRequestPriority.ACCURACY,
          scenario: geoLocationManager.LocationRequestScenario.UNSET,
          maxAccuracy: 50,
          timeoutMs: 8000
        })
        if (location) {
          const locationInfo = await this.buildLocationInfo(location)
          if (this.cachedLocation) {
            const distance = this.calculateDistance(
              this.cachedLocation.latitude, this.cachedLocation.longitude,
              locationInfo.latitude, locationInfo.longitude
            )
            if (distance > 50) {
              this.updateCache(locationInfo)
              this.notifyLocationChange(locationInfo)
              console.info(`[LocationService] ğŸ¯ GPS ç²¾ç¡®ä½ç½®å·²æ›´æ–°ï¼ˆåå·® ${distance.toFixed(0)}mï¼‰`)
            }
          } else {
            this.updateCache(locationInfo)
            this.notifyLocationChange(locationInfo)
          }
        }
      } catch (e) {
        console.warn('[LocationService] åå° GPS å®šä½å¤±è´¥')
      }
    }, 100)
  }
  startLocationListener(): void {
    if (this.isListening) {
      return
    }
    try {
      const locationRequest: geoLocationManager.LocationRequest = {
        priority: geoLocationManager.LocationRequestPriority.FIRST_FIX,
        scenario: geoLocationManager.LocationRequestScenario.UNSET,
        timeInterval: 60,
        distanceInterval: 100,
        maxAccuracy: 200
      }
      geoLocationManager.on('locationChange', locationRequest, async (location) => {
        console.info(`[LocationService] ğŸ“ ä½ç½®å˜åŒ–: ${location.latitude}, ${location.longitude}`)
        const locationInfo = await this.buildLocationInfoQuick(location)
        this.updateCache(locationInfo)
        this.notifyLocationChange(locationInfo)
      })
      this.isListening = true
      console.info('[LocationService] âœ… ä½ç½®ç›‘å¬å·²å¯åŠ¨')
    } catch (e) {
      console.warn('[LocationService] å¯åŠ¨ä½ç½®ç›‘å¬å¤±è´¥: ' + JSON.stringify(e))
    }
  }
  stopLocationListener(): void {
    if (!this.isListening) {
      return
    }
    try {
      geoLocationManager.off('locationChange')
      this.isListening = false
      console.info('[LocationService] ä½ç½®ç›‘å¬å·²åœæ­¢')
    } catch (e) {
      console.warn('[LocationService] åœæ­¢ä½ç½®ç›‘å¬å¤±è´¥')
    }
  }
  onLocationChange(callback: LocationChangeCallback): void {
    this.locationCallbacks.push(callback)
  }
  offLocationChange(callback: LocationChangeCallback): void {
    const index = this.locationCallbacks.indexOf(callback)
    if (index > -1) {
      this.locationCallbacks.splice(index, 1)
    }
  }
  private notifyLocationChange(location: LocationInfo): void {
    for (let i = 0; i < this.locationCallbacks.length; i++) {
      try {
        this.locationCallbacks[i](location)
      } catch (e) {
        console.warn('[LocationService] å›è°ƒæ‰§è¡Œå¤±è´¥')
      }
    }
  }
  private isCacheValid(): boolean {
    if (!this.cachedLocation) {
      return false
    }
    return Date.now() - this.cacheTimestamp < this.CACHE_VALID_MS
  }
  private updateCache(location: LocationInfo): void {
    this.cachedLocation = location
    this.cacheTimestamp = Date.now()
  }
  private async tryGetLocation(
    type: string,
    request: geoLocationManager.CurrentLocationRequest
  ): Promise<geoLocationManager.Location | null> {
    try {
      const location = await geoLocationManager.getCurrentLocation(request)
      console.info(`[LocationService] ${type} å®šä½: ${location.latitude}, ${location.longitude}`)
      return location
    } catch (error) {
      console.warn(`[LocationService] ${type} å®šä½å¤±è´¥: ${JSON.stringify(error)}`)
      return null
    }
  }
  private async getLastKnownLocation(): Promise<geoLocationManager.Location | null> {
    try {
      const location = await geoLocationManager.getLastLocation()
      if (location) {
        console.info(`[LocationService] æœ€åä½ç½®: ${location.latitude}, ${location.longitude}`)
        return location
      }
      return null
    } catch (error) {
      console.warn('[LocationService] è·å–æœ€åä½ç½®å¤±è´¥: ' + JSON.stringify(error))
      return null
    }
  }
  private async buildLocationInfoQuick(location: geoLocationManager.Location): Promise<LocationInfo> {
    const locationInfo: LocationInfo = {
      latitude: location.latitude,
      longitude: location.longitude,
      city: 'å½“å‰ä½ç½®',
      address: ''
    }
    this.getAddressAsync(location.latitude, location.longitude).then((address) => {
      if (address && this.cachedLocation) {
        this.cachedLocation.city = address.city
        this.cachedLocation.address = address.address
        this.notifyLocationChange(this.cachedLocation)
      }
    })
    return locationInfo
  }
  private async buildLocationInfo(location: geoLocationManager.Location): Promise<LocationInfo> {
    const locationInfo: LocationInfo = {
      latitude: location.latitude,
      longitude: location.longitude,
      city: '',
      address: ''
    }
    try {
      const addressPromise = this.getAddressAsync(location.latitude, location.longitude)
      const timeoutPromise = new Promise<null>((resolve) => setTimeout(() => resolve(null), 2000))
      const address = await Promise.race([addressPromise, timeoutPromise])
      if (address) {
        locationInfo.city = address.city
        locationInfo.address = address.address
      } else {
        locationInfo.city = 'å½“å‰ä½ç½®'
      }
    } catch (geoError) {
      console.warn('[LocationService] é€†åœ°ç†ç¼–ç å¤±è´¥: ' + JSON.stringify(geoError))
      locationInfo.city = 'å½“å‰ä½ç½®'
    }
    return locationInfo
  }
  private async getAddressAsync(latitude: number, longitude: number): Promise<{ city: string, address: string } | null> {
    try {
      const reverseRequest: geoLocationManager.ReverseGeoCodeRequest = {
        latitude: latitude,
        longitude: longitude,
        maxItems: 1
      }
      const addresses = await geoLocationManager.getAddressesFromLocation(reverseRequest)
      if (addresses.length > 0) {
        const addr = addresses[0]
        const city = (addr.administrativeArea || '') + ', ' + (addr.locality || '')
        const address = addr.placeName || ''
        console.info('[LocationService] åŸå¸‚: ' + city)
        return { city, address }
      }
    } catch (e) {
      console.warn('[LocationService] è·å–åœ°å€å¤±è´¥')
    }
    return null
  }
  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {
    const R = 6371000
    const dLat = (lat2 - lat1) * Math.PI / 180
    const dLng = (lng2 - lng1) * Math.PI / 180
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2)
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
    return R * c
  }
  getCachedLocation(): LocationInfo | null {
    return this.cachedLocation
  }
  getDefaultLocation(): LocationInfo {
    return {
      latitude: 23.1291,
      longitude: 113.2644,
      city: 'å¹¿ä¸œçœ, å¹¿å·å¸‚',
      address: 'å¹¿å·å¸‚'
    }
  }
}
// æ–‡ä»¶: entry/src/main/ets/utils/NotificationService.ets
import { notificationManager } from '@kit.NotificationKit'
import { hilog } from '@kit.PerformanceAnalysisKit'
import { wantAgent, common } from '@kit.AbilityKit'
import { ReminderService } from './ReminderService'
const DOMAIN = 0x0001;
const TAG = 'NotificationService';
export class NotificationService {
  private static instance: NotificationService;
  private slotInitialized: boolean = false;
  private context?: common.UIAbilityContext;
  private constructor() {}
  setContext(context: common.UIAbilityContext): void {
    this.context = context;
  }
  static getInstance(): NotificationService {
    if (!NotificationService.instance) {
      NotificationService.instance = new NotificationService();
    }
    return NotificationService.instance;
  }
  private async initNotificationSlot(): Promise<void> {
    if (this.slotInitialized) {
      return;
    }
    try {
      await notificationManager.addSlot(notificationManager.SlotType.SOCIAL_COMMUNICATION);
      this.slotInitialized = true;
      hilog.info(DOMAIN, TAG, 'é€šçŸ¥æ¸ é“åˆå§‹åŒ–æˆåŠŸ');
    } catch (err) {
      hilog.error(DOMAIN, TAG, `åˆå§‹åŒ–é€šçŸ¥æ¸ é“å¤±è´¥: ${JSON.stringify(err)}`);
    }
  }
  async checkNotificationEnabled(): Promise<boolean> {
    try {
      const enabled = await notificationManager.isNotificationEnabled();
      hilog.info(DOMAIN, TAG, `é€šçŸ¥æƒé™çŠ¶æ€: ${enabled}`);
      return enabled;
    } catch (err) {
      hilog.error(DOMAIN, TAG, `æ£€æŸ¥é€šçŸ¥æƒé™å¤±è´¥: ${JSON.stringify(err)}`);
      return false;
    }
  }
  async requestNotificationPermission(): Promise<void> {
    try {
      await notificationManager.requestEnableNotification();
      hilog.info(DOMAIN, TAG, 'é€šçŸ¥æƒé™è¯·æ±‚å·²å‘é€');
    } catch (err) {
      hilog.error(DOMAIN, TAG, `è¯·æ±‚é€šçŸ¥æƒé™å¤±è´¥: ${JSON.stringify(err)}`);
    }
  }
  async sendPollenAlert(level: string, value: number, city: string): Promise<void> {
    try {
      hilog.info(DOMAIN, TAG, `[DEBUG] è¿›å…¥ sendPollenAlert: level=${level}, value=${value}, city=${city}`);
      const notificationEnabled = AppStorage.get<boolean>('notificationEnabled') ?? false;
      if (!notificationEnabled) {
        hilog.info(DOMAIN, TAG, 'é€šçŸ¥æ€»å¼€å…³å·²å…³é—­ï¼Œè·³è¿‡æ¨é€');
        return;
      }
      const pollenAlertEnabled = AppStorage.get<boolean>('pollenAlertEnabled') ?? false;
      if (!pollenAlertEnabled) {
        hilog.info(DOMAIN, TAG, 'èŠ±ç²‰é¢„è­¦å¼€å…³å·²å…³é—­ï¼Œè·³è¿‡æ¨é€');
        return;
      }
      const hasPermission = await this.checkNotificationEnabled();
      if (!hasPermission) {
        hilog.warn(DOMAIN, TAG, 'æ— é€šçŸ¥æƒé™ï¼Œæ— æ³•å‘é€é€šçŸ¥');
        return;
      }
      await this.initNotificationSlot();
      const wantAgentObj = await this.createWantAgent();
      const request: notificationManager.NotificationRequest = {
        id: Math.floor(Math.random() * 1000),
        notificationSlotType: notificationManager.SlotType.SOCIAL_COMMUNICATION,
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: `${city} èŠ±ç²‰é¢„è­¦`,
            text: `èŠ±ç²‰ç­‰çº§ï¼š${level}ï¼ˆ${value} ç²’/kmÂ³ï¼‰\nå»ºè®®å‡å°‘æˆ·å¤–æ´»åŠ¨ï¼Œå¤–å‡ºä½©æˆ´å£ç½©`,
            additionalText: 'ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…'
          }
        },
        deliveryTime: new Date().getTime(),
        wantAgent: wantAgentObj
      };
      await notificationManager.publish(request);
      hilog.info(DOMAIN, TAG, `èŠ±ç²‰é¢„è­¦é€šçŸ¥å·²å‘é€: ${city} - ${level}`);
    } catch (err) {
      hilog.error(DOMAIN, TAG, `å‘é€èŠ±ç²‰é¢„è­¦é€šçŸ¥å¤±è´¥: ${JSON.stringify(err)}`);
    }
  }
  async sendDailyReport(level: string, value: number, city: string, tips: string[]): Promise<void> {
    try {
      const notificationEnabled = AppStorage.get<boolean>('notificationEnabled') ?? false;
      if (!notificationEnabled) {
        hilog.info(DOMAIN, TAG, 'é€šçŸ¥æ€»å¼€å…³å·²å…³é—­ï¼Œè·³è¿‡æ¨é€');
        return;
      }
      const dailyReportEnabled = AppStorage.get<boolean>('dailyReportEnabled') ?? false;
      if (!dailyReportEnabled) {
        hilog.info(DOMAIN, TAG, 'æ¯æ—¥æ’­æŠ¥å¼€å…³å·²å…³é—­ï¼Œè·³è¿‡æ¨é€');
        return;
      }
      const hasPermission = await this.checkNotificationEnabled();
      if (!hasPermission) {
        hilog.warn(DOMAIN, TAG, 'æ— é€šçŸ¥æƒé™ï¼Œæ— æ³•å‘é€é€šçŸ¥');
        return;
      }
      const wantAgentObj = await this.createWantAgent();
      const tipsText = tips.length > 0 ? `\n${tips[0]}` : '';
      const request: notificationManager.NotificationRequest = {
        id: 2,
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: `${city} ä»Šæ—¥èŠ±ç²‰æ’­æŠ¥`,
            text: `èŠ±ç²‰ç­‰çº§ï¼š${level}ï¼ˆ${value} ç²’/kmÂ³ï¼‰${tipsText}`,
            additionalText: 'ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…'
          }
        },
        isOngoing: false,
        isUnremovable: false,
        deliveryTime: new Date().getTime(),
        tapDismissed: true,
        autoDeletedTime: 7200000,
        wantAgent: wantAgentObj
      };
      await notificationManager.publish(request);
      hilog.info(DOMAIN, TAG, `æ¯æ—¥æ’­æŠ¥é€šçŸ¥å·²å‘é€: ${city} - ${level}`);
    } catch (err) {
      hilog.error(DOMAIN, TAG, `å‘é€æ¯æ—¥æ’­æŠ¥é€šçŸ¥å¤±è´¥: ${JSON.stringify(err)}`);
    }
  }
  private async createWantAgent(): Promise<object | undefined> {
    try {
      const wantAgentInfo: wantAgent.WantAgentInfo = {
        wants: [
          {
            bundleName: 'com.eric.PollenForecast',
            abilityName: 'EntryAbility',
            parameters: {
              router: 'pages/Index',
              tab: 0
            }
          }
        ],
        requestCode: 0,
        actionType: wantAgent.OperationType.START_ABILITY,
        actionFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
      };
      const wantAgentObj = await wantAgent.getWantAgent(wantAgentInfo);
      hilog.info(DOMAIN, TAG, 'WantAgentåˆ›å»ºæˆåŠŸ');
      return wantAgentObj;
    } catch (err) {
      hilog.error(DOMAIN, TAG, `WantAgentåˆ›å»ºå¤±è´¥: ${JSON.stringify(err)}`);
      return undefined;
    }
  }
  async cancelAllNotifications(): Promise<void> {
    try {
      await notificationManager.cancelAll();
      hilog.info(DOMAIN, TAG, 'å·²å–æ¶ˆæ‰€æœ‰é€šçŸ¥');
    } catch (err) {
      hilog.error(DOMAIN, TAG, `å–æ¶ˆé€šçŸ¥å¤±è´¥: ${JSON.stringify(err)}`);
    }
  }
  async scheduleDailyReminder(timeStr: string): Promise<boolean> {
    try {
      hilog.info(DOMAIN, TAG, `è®¾ç½®æ¯æ—¥æ’­æŠ¥å®šæ—¶æé†’: ${timeStr}`);
      AppStorage.setOrCreate('dailyReminderTime', timeStr);
      AppStorage.setOrCreate('dailyReportEnabled', true);
      const reminderService = ReminderService.getInstance();
      const success = await reminderService.scheduleDailyReminder(timeStr);
      if (success) {
        hilog.info(DOMAIN, TAG, `âœ… æ¯æ—¥æ’­æŠ¥å®šæ—¶æé†’è®¾ç½®æˆåŠŸ: ${timeStr}`);
      } else {
        hilog.warn(DOMAIN, TAG, `âš ï¸ ä»£ç†æé†’è®¾ç½®å¤±è´¥ï¼Œå°†ä½¿ç”¨åº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥æ–¹æ¡ˆ`);
      }
      return true;
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : JSON.stringify(err);
      hilog.error(DOMAIN, TAG, `è®¾ç½®å®šæ—¶æé†’å¤±è´¥: ${errorMsg}`);
      return false;
    }
  }
  async cancelDailyReminder(): Promise<void> {
    try {
      AppStorage.delete('dailyReminderTime');
      AppStorage.setOrCreate('dailyReportEnabled', false);
      const reminderService = ReminderService.getInstance();
      await reminderService.cancelReminder();
      hilog.info(DOMAIN, TAG, 'å·²å–æ¶ˆæ¯æ—¥æ’­æŠ¥');
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : JSON.stringify(err);
      hilog.error(DOMAIN, TAG, `å–æ¶ˆå®šæ—¶æé†’å¤±è´¥: ${errorMsg}`);
    }
  }
  async checkAndSendDailyReport(): Promise<void> {
    try {
      const notificationEnabled = AppStorage.get<boolean>('notificationEnabled') ?? false;
      if (!notificationEnabled) {
        hilog.info(DOMAIN, TAG, 'é€šçŸ¥æ€»å¼€å…³å·²å…³é—­ï¼Œè·³è¿‡æ¯æ—¥æ’­æŠ¥æ£€æŸ¥');
        return;
      }
      const dailyReportEnabled = AppStorage.get<boolean>('dailyReportEnabled') ?? false;
      if (!dailyReportEnabled) {
        hilog.info(DOMAIN, TAG, 'æ¯æ—¥æ’­æŠ¥å·²å…³é—­ï¼Œè·³è¿‡æ£€æŸ¥');
        return;
      }
      const timeStr = AppStorage.get<string>('dailyReminderTime') ?? '08:00';
      const timeParts: string[] = timeStr.split(':');
      const hour = parseInt(timeParts[0]);
      const minute = parseInt(timeParts[1]);
      const lastSentDate = AppStorage.get<string>('lastDailyReportDate') ?? '';
      const today = new Date().toDateString();
      if (lastSentDate === today) {
        hilog.info(DOMAIN, TAG, 'ä»Šæ—¥æ’­æŠ¥å·²å‘é€ï¼Œè·³è¿‡');
        return;
      }
      const now = new Date();
      const targetTime = new Date();
      targetTime.setHours(hour, minute, 0, 0);
      if (now.getTime() >= targetTime.getTime()) {
        hilog.info(DOMAIN, TAG, 'è§¦å‘æ¯æ—¥æ’­æŠ¥é€šçŸ¥ï¼ˆåº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥ï¼‰');
        const city = AppStorage.get<string>('currentCity') ?? 'æœªçŸ¥';
        const level = AppStorage.get<string>('pollenLevel') ?? 'æœªçŸ¥';
        const value = AppStorage.get<number>('pollenValue') ?? 0;
        await this.sendDailyReport(level, value, city, []);
        AppStorage.setOrCreate('lastDailyReportDate', today);
        hilog.info(DOMAIN, TAG, `âœ… æ¯æ—¥æ’­æŠ¥å·²å‘é€: ${city} - ${level}`);
      } else {
        hilog.info(DOMAIN, TAG, `å½“å‰æ—¶é—´æœªåˆ°è®¾å®šæ—¶é—´ ${timeStr}ï¼Œè·³è¿‡æ’­æŠ¥`);
      }
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : JSON.stringify(err);
      hilog.error(DOMAIN, TAG, `æ¯æ—¥æ’­æŠ¥æ£€æŸ¥å¤±è´¥: ${errorMsg}`);
    }
  }
  async checkReminderPermission(): Promise<boolean> {
    return true;
  }
}
// æ–‡ä»¶: entry/src/main/ets/utils/ReminderService.ets
import { reminderAgentManager } from '@kit.BackgroundTasksKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { notificationManager } from '@kit.NotificationKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
const DOMAIN = 0x0001;
const TAG = 'ReminderService';
const REMINDER_ID_KEY = 'dailyReminderAgentId';
interface ReminderRequestWithId {
  reminderId?: number;
}
export class ReminderService {
  private static instance: ReminderService;
  private reminderId: number = -1;
  private constructor() {
    const savedId = AppStorage.get<number>(REMINDER_ID_KEY);
    if (savedId !== undefined && savedId !== -1) {
      this.reminderId = savedId;
      hilog.info(DOMAIN, TAG, `æ¢å¤å·²ä¿å­˜çš„æé†’ID: ${this.reminderId}`);
    }
  }
  static getInstance(): ReminderService {
    if (!ReminderService.instance) {
      ReminderService.instance = new ReminderService();
    }
    return ReminderService.instance;
  }
  async cancelAllReminders(): Promise<void> {
    try {
      const reminders = await reminderAgentManager.getValidReminders();
      hilog.info(DOMAIN, TAG, `å½“å‰æœ‰æ•ˆæé†’æ•°é‡: ${reminders.length}`);
      for (let i = 0; i < reminders.length; i++) {
        const reminder = reminders[i];
        const reminderStr = JSON.stringify(reminder);
        const reminderObj: ReminderRequestWithId = JSON.parse(reminderStr) as ReminderRequestWithId;
        const id = reminderObj.reminderId;
        if (id !== undefined) {
          try {
            await reminderAgentManager.cancelReminder(id);
            hilog.info(DOMAIN, TAG, `å·²å–æ¶ˆæé†’ ID: ${id}`);
          } catch (cancelErr) {
            const cancelError = cancelErr as BusinessError;
            hilog.warn(DOMAIN, TAG, `å–æ¶ˆæé†’ ${id} å¤±è´¥: ${cancelError.message}`);
          }
        }
      }
      this.reminderId = -1;
      AppStorage.delete(REMINDER_ID_KEY);
      hilog.info(DOMAIN, TAG, `âœ… å·²æ¸…ç†æ‰€æœ‰æ—§æé†’ï¼Œå…± ${reminders.length} ä¸ª`);
    } catch (err) {
      const error = err as BusinessError;
      hilog.error(DOMAIN, TAG, `æ¸…ç†æ—§æé†’å¤±è´¥: ${error.code} - ${error.message}`);
    }
  }
  async scheduleDailyReminder(timeStr: string): Promise<boolean> {
    try {
      hilog.info(DOMAIN, TAG, `è®¾ç½®æ¯æ—¥æé†’: ${timeStr}`);
      const timeParts: string[] = timeStr.split(':');
      const hour = parseInt(timeParts[0]);
      const minute = parseInt(timeParts[1]);
      if (isNaN(hour) || isNaN(minute)) {
        hilog.error(DOMAIN, TAG, `æ— æ•ˆçš„æ—¶é—´æ ¼å¼: ${timeStr}`);
        return false;
      }
      await this.cancelAllReminders();
      const reminderRequest: reminderAgentManager.ReminderRequestAlarm = {
        reminderType: reminderAgentManager.ReminderType.REMINDER_TYPE_ALARM,
        hour: hour,
        minute: minute,
        daysOfWeek: [1, 2, 3, 4, 5, 6, 7],
        title: 'ğŸŒ¼ èŠ±ç²‰æµ“åº¦æ’­æŠ¥',
        content: 'ä»Šæ—¥èŠ±ç²‰æµ“åº¦ä¿¡æ¯å·²æ›´æ–°ï¼Œç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…',
        expiredContent: 'èŠ±ç²‰æ’­æŠ¥å·²è¿‡æœŸ',
        snoozeContent: 'ç¨€åæé†’',
        notificationId: 1001,
        slotType: notificationManager.SlotType.SOCIAL_COMMUNICATION,
        ringDuration: 10,
        snoozeTimes: 2,
        timeInterval: 5 * 60,
        actionButton: [
          {
            title: 'ç¨€åæé†’',
            type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_SNOOZE
          },
          {
            title: 'å…³é—­',
            type: reminderAgentManager.ActionButtonType.ACTION_BUTTON_TYPE_CLOSE
          }
        ],
        wantAgent: {
          pkgName: 'com.eric.PollenForecast',
          abilityName: 'EntryAbility'
        }
      };
      hilog.info(DOMAIN, TAG, `æé†’é…ç½®: hour=${hour}, minute=${minute}`);
      this.reminderId = await reminderAgentManager.publishReminder(reminderRequest);
      AppStorage.setOrCreate(REMINDER_ID_KEY, this.reminderId);
      hilog.info(DOMAIN, TAG, `âœ… æ¯æ—¥æé†’è®¾ç½®æˆåŠŸï¼ŒID: ${this.reminderId}`);
      return true;
    } catch (err) {
      const error = err as BusinessError;
      hilog.error(DOMAIN, TAG, `è®¾ç½®æé†’å¤±è´¥: ${error.code} - ${error.message}`);
      return false;
    }
  }
  async cancelReminder(): Promise<void> {
    try {
      if (this.reminderId !== -1) {
        await reminderAgentManager.cancelReminder(this.reminderId);
        hilog.info(DOMAIN, TAG, `å·²å–æ¶ˆæé†’ï¼ŒID: ${this.reminderId}`);
        this.reminderId = -1;
        AppStorage.delete(REMINDER_ID_KEY);
      }
    } catch (err) {
      const error = err as BusinessError;
      hilog.error(DOMAIN, TAG, `å–æ¶ˆæé†’å¤±è´¥: ${error.code} - ${error.message}`);
    }
  }
  async getValidReminders(): Promise<reminderAgentManager.ReminderRequest[]> {
    try {
      const reminders = await reminderAgentManager.getValidReminders();
      hilog.info(DOMAIN, TAG, `å½“å‰æœ‰æ•ˆæé†’æ•°é‡: ${reminders.length}`);
      return reminders;
    } catch (err) {
      const error = err as BusinessError;
      hilog.error(DOMAIN, TAG, `è·å–æé†’å¤±è´¥: ${error.code} - ${error.message}`);
      return [];
    }
  }
}
// æ–‡ä»¶: entry/src/main/ets/widget/PollenCard.ets
let storage = new LocalStorage();
@Entry(storage)
@Component
export struct PollenCard {
  @LocalStorageProp('pollenValue') pollenValue: string = '45'
  @LocalStorageProp('pollenLevel') pollenLevel: string = 'ä¸­ç­‰'
  @LocalStorageProp('cityName') cityName: string = 'å¹¿å·'
  build() {
    Stack() {
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor($r('app.color.card_background'))
      Row() {
        Text('ğŸ“')
          .fontSize(14)
          .fontColor('#666666')
        Text(this.cityName)
          .fontSize(14)
          .fontColor('#666666')
          .margin({ left: 4 })
      }
      .position({ x: 12, y: 12 })
      Column({
        space: 2
      }) {
        Text(this.pollenValue)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
          .fontColor('#4CAF50')
          .lineHeight(56)
        Text('ç²’/kmÂ³')
          .fontSize(12)
          .fontColor('#757575')
      }
      .alignItems(HorizontalAlign.Center)
      .justifyContent(FlexAlign.Center)
      .position({ x: '50%', y: '45%' })
      .translate({ x: '-50%', y: '-50%' })
      Text(this.pollenLevel)
        .fontSize(14)
        .fontColor('#FF9800')
        .backgroundColor('#FFF3E0')
        .padding({ left: 16, right: 16, top: 6, bottom: 6 })
        .borderRadius(50)
        .position({ x: '50%', y: '85%' })
        .translate({ x: '-50%' })
    }
    .width('100%')
    .height('100%')
    .borderRadius(12)
    .clip(true)
    .onClick(() => {
      postCardAction(this, {
        action: 'router',
        abilityName: 'EntryAbility',
        params: {
          targetPage: 'index'
        }
      });
    })
  }
}
// æ–‡ä»¶: entry/src/main/ets/model/PollenModels.ets (éƒ¨åˆ†)
export function levelToColor(level: PollenLevel): string {
  if (level === PollenLevel.NONE) {
    return '#4CAF50'
  } else if (level === PollenLevel.VERY_LOW) {
    return '#8BC34A'
  } else if (level === PollenLevel.LOW) {
    return '#CDDC39'
  } else if (level === PollenLevel.MODERATE) {
    return '#FFC107'
  } else if (level === PollenLevel.HIGH) {
    return '#FF9800'
  } else if (level === PollenLevel.VERY_HIGH) {
    return '#F44336'
  }
  return '#757575'
}
export function formatDateShort(dateInfo: DateInfo): string {
  const month = dateInfo.month.toString().padStart(2, '0')
  const day = dateInfo.day.toString().padStart(2, '0')
  return `${month}/${day}`
}
export function getMaxPollenFromDaily(dayInfo: DailyInfo): PollenLevel {
  let maxLevel = PollenLevel.NONE
  if (dayInfo.pollenTypeInfo && dayInfo.pollenTypeInfo.length > 0) {
    for (let i = 0; i < dayInfo.pollenTypeInfo.length; i++) {
      const typeInfo = dayInfo.pollenTypeInfo[i]
      if (typeInfo.indexInfo !== null && typeInfo.indexInfo !== undefined) {
        const category = typeInfo.indexInfo.category || 'None'
        const level = categoryToLevel(category)
        if (level > maxLevel) {
          maxLevel = level
        }
      }
    }
  }
  return maxLevel
}
export function getMaxPollenIndexFromDaily(dayInfo: DailyInfo): number {
  let maxIndex = 0
  if (dayInfo.pollenTypeInfo && dayInfo.pollenTypeInfo.length > 0) {
    for (let i = 0; i < dayInfo.pollenTypeInfo.length; i++) {
      const typeInfo = dayInfo.pollenTypeInfo[i]
      if (typeInfo.indexInfo !== null && typeInfo.indexInfo !== undefined) {
        const value = typeInfo.indexInfo.value || 0
        if (value > maxIndex) {
          maxIndex = value
        }
      }
    }
  }
  return maxIndex
}
export function getHealthRecommendationsFromDaily(dayInfo: DailyInfo): string[] {
  const recommendations: Set<string> = new Set()
  if (dayInfo.pollenTypeInfo && dayInfo.pollenTypeInfo.length > 0) {
    for (const typeInfo of dayInfo.pollenTypeInfo) {
      if (typeInfo.healthRecommendations && typeInfo.healthRecommendations.length > 0) {
        for (const rec of typeInfo.healthRecommendations) {
          if (rec && rec.trim().length > 0) {
            recommendations.add(rec)
          }
        }
      }
    }
  }
  return Array.from(recommendations)
}
// æ–‡ä»¶: entry/src/main/ets/utils/VibrationUtils.ets
import { vibrator } from '@kit.SensorServiceKit'
export class VibrationUtils {
  static triggerLight(): void {
    const vibrationEnabled = AppStorage.get<boolean>('vibrationEnabled') ?? false
    if (!vibrationEnabled) {
      return
    }
    try {
      vibrator.startVibration({
        type: 'time',
        duration: 15
      }, {
        id: 0,
        usage: 'touch'
      }, (error) => {
        if (error) {
          console.error('[VibrationUtils] è½»é‡éœ‡åŠ¨å¤±è´¥:', JSON.stringify(error))
        }
      })
    } catch (err) {
      console.error('[VibrationUtils] è½»é‡éœ‡åŠ¨å¼‚å¸¸:', JSON.stringify(err))
    }
  }
  static triggerMedium(): void {
    const vibrationEnabled = AppStorage.get<boolean>('vibrationEnabled') ?? false
    if (!vibrationEnabled) {
      return
    }
    try {
      vibrator.startVibration({
        type: 'time',
        duration: 35
      }, {
        id: 0,
        usage: 'touch'
      }, (error) => {
        if (error) {
          console.error('[VibrationUtils] ä¸­ç­‰éœ‡åŠ¨å¤±è´¥:', JSON.stringify(error))
        }
      })
    } catch (err) {
      console.error('[VibrationUtils] ä¸­ç­‰éœ‡åŠ¨å¼‚å¸¸:', JSON.stringify(err))
    }
  }
  static triggerHeavy(): void {
    const vibrationEnabled = AppStorage.get<boolean>('vibrationEnabled') ?? false
    if (!vibrationEnabled) {
      return
    }
    try {
      vibrator.startVibration({
        type: 'time',
        duration: 50
      }, {
        id: 0,
        usage: 'alarm'
      }, (error) => {
        if (error) {
          console.error('[VibrationUtils] é‡åº¦éœ‡åŠ¨å¤±è´¥:', JSON.stringify(error))
        }
      })
    } catch (err) {
      console.error('[VibrationUtils] é‡åº¦éœ‡åŠ¨å¼‚å¸¸:', JSON.stringify(err))
    }
  }
}
// æ–‡ä»¶: entry/src/main/ets/utils/SeasonHelper.ets
export enum SeasonType {
  SPRING_POLLEN = 'spring_pollen',
  SUMMER = 'summer',
  AUTUMN_POLLEN = 'autumn_pollen',
  WINTER = 'winter'
}
export interface OffSeasonContent {
  title: string
  description: string
  tips: string[]
  nextSeasonHint: string
}
export class SeasonHelper {
  static getCurrentSeason(): SeasonType {
    const month = new Date().getMonth() + 1
    if (month >= 3 && month <= 5) {
      return SeasonType.SPRING_POLLEN
    } else if (month >= 6 && month <= 7) {
      return SeasonType.SUMMER
    } else if (month >= 8 && month <= 10) {
      return SeasonType.AUTUMN_POLLEN
    } else {
      return SeasonType.WINTER
    }
  }
  static isPollenSeason(): boolean {
    const season = SeasonHelper.getCurrentSeason()
    return season === SeasonType.SPRING_POLLEN || season === SeasonType.AUTUMN_POLLEN
  }
  static getCurrentMonth(): number {
    return new Date().getMonth() + 1
  }
  static getOffSeasonContent(): OffSeasonContent {
    const season = SeasonHelper.getCurrentSeason()
    const month = SeasonHelper.getCurrentMonth()
    if (season === SeasonType.WINTER) {
      return {
        title: 'å†¬å­£èŠ±ç²‰ä¼‘çœ æœŸ',
        description: 'å½“å‰ä¸ºå†¬å­£ï¼Œå¤§éƒ¨åˆ†åœ°åŒºèŠ±ç²‰æµ“åº¦æä½ï¼Œæ˜¯è¿‡æ•æ‚£è€…çš„èˆ’é€‚æœŸã€‚',
        tips: [
          'ğŸŒ¿ å¯é€‚å½“è¿›è¡Œæˆ·å¤–æ´»åŠ¨ï¼Œå‘¼å¸æ–°é²œç©ºæ°”',
          'ğŸ  è¶æ­¤æ—¶æœŸè¿›è¡Œå®¶åº­å¤§æ‰«é™¤ï¼Œæ¸…é™¤ç§¯å°˜',
          'ğŸ’ª åŠ å¼ºé”»ç‚¼ï¼Œå¢å¼ºä½“è´¨ï¼Œä¸ºèŠ±ç²‰å­£åšå‡†å¤‡',
          'ğŸ“… æå‰å…³æ³¨æ˜å¹´èŠ±ç²‰å­£é¢„æŠ¥'
        ],
        nextSeasonHint: 'ä¸‹ä¸€ä¸ªèŠ±ç²‰å­£é¢„è®¡åœ¨3æœˆå¼€å§‹ï¼ˆæ˜¥å­£èŠ±ç²‰å­£ï¼‰'
      }
    } else if (season === SeasonType.SUMMER) {
      return {
        title: 'å¤å­£è¿‡æ¸¡æœŸ',
        description: 'å¤å­£èŠ±ç²‰æµ“åº¦ç›¸å¯¹è¾ƒä½ï¼Œä½†éƒ¨åˆ†åœ°åŒºä»æœ‰è‰æœ¬æ¤ç‰©èŠ±ç²‰ã€‚',
        tips: [
          'ğŸŒ¾ æ³¨æ„è‰åœ°èŠ±ç²‰ï¼Œé¿å…åœ¨è‰åªä¹…ç•™',
          'â˜€ï¸ é«˜æ¸©å¤©æ°”æ³¨æ„é˜²æš‘ï¼Œå‡å°‘æ­£åˆå¤–å‡º',
          'ğŸ’¨ é›·é›¨å¤©æ°”åèŠ±ç²‰æµ“åº¦å¯èƒ½å‡é«˜',
          'ğŸ”” 8æœˆç§‹å­£èŠ±ç²‰å­£å³å°†æ¥ä¸´ï¼Œæå‰å‡†å¤‡'
        ],
        nextSeasonHint: 'ç§‹å­£èŠ±ç²‰å­£é¢„è®¡åœ¨8æœˆå¼€å§‹ï¼ˆè’¿è‰ã€è±šè‰é«˜å‘ï¼‰'
      }
    }
    return {
      title: 'èŠ±ç²‰ç›‘æµ‹ä¸­',
      description: 'æ­£åœ¨è·å–èŠ±ç²‰æ•°æ®...',
      tips: ['è¯·ç¨å€™...'],
      nextSeasonHint: ''
    }
  }
  static getPollenSeasonTips(): string[] {
    const season = SeasonHelper.getCurrentSeason()
    if (season === SeasonType.SPRING_POLLEN) {
      return [
        'ğŸŒ³ æ˜¥å­£ä¸»è¦èŠ±ç²‰ï¼šæŸæ ‘ã€æ¨æ ‘ã€æŸ³æ ‘ã€æ¦†æ ‘',
        'ğŸ˜· å¤–å‡ºä½©æˆ´é˜²æŠ¤å£ç½©å’ŒæŠ¤ç›®é•œ',
        'ğŸš¿ å›å®¶ååŠæ—¶æ´—è„¸ã€æ´—æ‰‹ã€æ¸…æ´—é¼»è…”',
        'ğŸªŸ èŠ±ç²‰é«˜å³°æœŸï¼ˆä¸Šåˆ10ç‚¹-ä¸‹åˆ4ç‚¹ï¼‰å…³é—­é—¨çª—',
        'ğŸ‘• å¤–å‡ºè¡£ç‰©å›å®¶ååŠæ—¶æ›´æ¢',
        'ğŸŒ¬ï¸ ä½¿ç”¨ç©ºæ°”å‡€åŒ–å™¨å‡€åŒ–å®¤å†…ç©ºæ°”'
      ]
    } else if (season === SeasonType.AUTUMN_POLLEN) {
      return [
        'ğŸŒ¿ ç§‹å­£ä¸»è¦èŠ±ç²‰ï¼šè’¿è‰ã€è±šè‰ã€è‘è‰',
        'ğŸ˜· ç§‹å­£èŠ±ç²‰è‡´æ•æ€§æ›´å¼ºï¼ŒåŠ¡å¿…åšå¥½é˜²æŠ¤',
        'ğŸš— å¼€è½¦æ—¶å…³é—­è½¦çª—ï¼Œä½¿ç”¨å†…å¾ªç¯',
        'ğŸ§º é¿å…åœ¨å®¤å¤–æ™¾æ™’è¡£ç‰©å’ŒåºŠå“',
        'ğŸ¥ ç—‡çŠ¶ä¸¥é‡æ—¶åŠæ—¶å°±åŒ»',
        'ğŸ’Š éµåŒ»å˜±æå‰ä½¿ç”¨é¢„é˜²æ€§è¯ç‰©'
      ]
    }
    return []
  }
  static getSeasonDescription(): string {
    const season = SeasonHelper.getCurrentSeason()
    switch (season) {
      case SeasonType.SPRING_POLLEN:
        return 'æ˜¥å­£èŠ±ç²‰å­£ï¼ˆ3-5æœˆï¼‰'
      case SeasonType.SUMMER:
        return 'å¤å­£è¿‡æ¸¡æœŸï¼ˆ6-7æœˆï¼‰'
      case SeasonType.AUTUMN_POLLEN:
        return 'ç§‹å­£èŠ±ç²‰å­£ï¼ˆ8-10æœˆï¼‰'
      case SeasonType.WINTER:
        return 'å†¬å­£ä¼‘çœ æœŸï¼ˆ11-2æœˆï¼‰'
      default:
        return ''
    }
  }
}
// æ–‡ä»¶: entry/src/main/ets/utils/ApiVersionUtils.ets
import { deviceInfo } from '@kit.BasicServicesKit';
let cachedApiVersion: number = -1;
function getApiVersionInternal(): number {
  if (cachedApiVersion === -1) {
    try {
      cachedApiVersion = deviceInfo.sdkApiVersion;
      console.info(`[ApiVersionUtils] å½“å‰è®¾å¤‡ API ç‰ˆæœ¬: ${cachedApiVersion}`);
    } catch (err) {
      console.error('[ApiVersionUtils] è·å– API ç‰ˆæœ¬å¤±è´¥:', JSON.stringify(err));
      cachedApiVersion = 20;
    }
  }
  return cachedApiVersion;
}
export class ApiVersionUtils {
  static getApiVersion(): number {
    return getApiVersionInternal();
  }
  static isAPI20(): boolean {
    return getApiVersionInternal() >= 20;
  }
  static isAPI17To19(): boolean {
    const version = getApiVersionInternal();
    return version >= 17 && version < 20;
  }
  static supportsMapEventManager(): boolean {
    return getApiVersionInternal() >= 20;
  }
  static supportsGripDetection(): boolean {
    return getApiVersionInternal() >= 20;
  }
  static getVersionDescription(): string {
    const version = getApiVersionInternal();
    if (version >= 20) {
      return `HarmonyOS 6.0+ (API ${version})`;
    } else if (version >= 17) {
      return `HarmonyOS 5.0 (API ${version})`;
    } else {
      return `HarmonyOS æ—§ç‰ˆæœ¬ (API ${version})`;
    }
  }
}
// æ–‡ä»¶: entry/src/main/ets/model/PollenDataSource.ets
export enum PollenDataSourceType {
  GOOGLE = 'GOOGLE',
  CMA = 'CMA',
  QWEATHER = 'QWEATHER',
  AUTO = 'AUTO'
}
export interface PollenDataSourceConfig {
  type: PollenDataSourceType
  name: string
  description: string
  coverage: string
  accuracy: string
  updateFrequency: string
  enabled: boolean
}
export const POLLEN_DATA_SOURCES: PollenDataSourceConfig[] = [
  {
    type: PollenDataSourceType.AUTO,
    name: 'è‡ªåŠ¨é€‰æ‹©',
    description: 'æ ¹æ®ç½‘ç»œå’Œä½ç½®è‡ªåŠ¨é€‰æ‹©æœ€ä½³æ•°æ®æº',
    coverage: 'å…¨çƒ',
    accuracy: 'é«˜',
    updateFrequency: 'å®æ—¶',
    enabled: true
  },
  {
    type: PollenDataSourceType.GOOGLE,
    name: 'Google Pollen API',
    description: 'å…¨çƒèŠ±ç²‰æ•°æ®ï¼Œè¦†ç›–èŒƒå›´å¹¿',
    coverage: 'å…¨çƒ',
    accuracy: 'é«˜',
    updateFrequency: 'æ¯æ—¥æ›´æ–°',
    enabled: true
  },
  {
    type: PollenDataSourceType.CMA,
    name: 'ä¸­å›½æ°”è±¡å±€',
    description: 'å›½å†…æƒå¨èŠ±ç²‰æ•°æ®',
    coverage: 'å›½å†…',
    accuracy: 'é«˜',
    updateFrequency: 'æ¯æ—¥æ›´æ–°',
    enabled: false
  },
  {
    type: PollenDataSourceType.QWEATHER,
    name: 'å’Œé£å¤©æ°”',
    description: 'å›½å†…èŠ±ç²‰æ•°æ®ï¼ˆå¦‚æœæ”¯æŒï¼‰',
    coverage: 'å›½å†…',
    accuracy: 'ä¸­',
    updateFrequency: 'æ¯æ—¥æ›´æ–°',
    enabled: false
  }
]
export function getDataSourceName(type: PollenDataSourceType): string {
  const source = POLLEN_DATA_SOURCES.find(s => s.type === type)
  return source?.name || 'æœªçŸ¥'
}
export function getDataSourceDescription(type: PollenDataSourceType): string {
  const source = POLLEN_DATA_SOURCES.find(s => s.type === type)
  return source?.description || ''
}
