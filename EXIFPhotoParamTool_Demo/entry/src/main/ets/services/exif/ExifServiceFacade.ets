/**
 * EXIFæœåŠ¡å¤–è§‚æ¨¡å¼ï¼ˆFacade Patternï¼‰
 * æä¾›ç»Ÿä¸€çš„EXIFè§£æå…¥å£ï¼Œæ•´åˆæ ‡å‡†EXIFå’Œé¸¿è’™ä¸“å±å­—æ®µ
 */
import { ExifData } from '../../models/PhotoRecord'
import { ExifParserService } from '../ExifParserService'
import { HarmonyExifService } from './HarmonyExifService'
import { common } from '@kit.AbilityKit'
import { hilog } from '@kit.PerformanceAnalysisKit'

/**
 * LRUç¼“å­˜å®ç°ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
 */
class LRUCache {
  private cache: Map<string, ExifData>
  private maxSize: number

  constructor(maxSize: number = 50) {
    this.cache = new Map<string, ExifData>()
    this.maxSize = maxSize
  }

  get(key: string): ExifData | undefined {
    if (!this.cache.has(key)) {
      return undefined
    }
    // LRU: é‡æ–°æ’å…¥åˆ°æœ«å°¾ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
    const value = this.cache.get(key)!
    this.cache.delete(key)
    this.cache.set(key, value)
    return value
  }

  set(key: string, value: ExifData): void {
    // å¦‚æœå·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤ï¼ˆé¿å…é‡å¤ï¼‰
    if (this.cache.has(key)) {
      this.cache.delete(key)
    }
    // å¦‚æœè¶…å‡ºå®¹é‡ï¼Œåˆ é™¤æœ€æ—§çš„ï¼ˆç¬¬ä¸€ä¸ªï¼‰
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value as string
      this.cache.delete(firstKey)
    }
    this.cache.set(key, value)
  }

  has(key: string): boolean {
    return this.cache.has(key)
  }

  clear(): void {
    this.cache.clear()
  }

  size(): number {
    return this.cache.size
  }
}

/**
 * EXIFæœåŠ¡å¤–è§‚ç±»
 * æ•´åˆæ ‡å‡†EXIFè§£æå’Œé¸¿è’™ä¸“å±ç‰¹æ€§æ£€æµ‹
 */
export class ExifServiceFacade {
  private static instance: ExifServiceFacade
  private exifParser: ExifParserService = new ExifParserService()
  private harmonyService: HarmonyExifService
  private cache: LRUCache

  private constructor() {
    this.harmonyService = new HarmonyExifService()
    this.cache = new LRUCache(50) // ç¼“å­˜æœ€è¿‘50å¼ ç…§ç‰‡
  }

  /**
   * åˆå§‹åŒ–ï¼ˆå¿…é¡»åœ¨ä½¿ç”¨å‰è°ƒç”¨ï¼‰
   */
  init(context: common.UIAbilityContext): void {
    this.exifParser.init(context)
    hilog.info(0x0021, 'EXIF', '[ExifFacade] åˆå§‹åŒ–å®Œæˆ')
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): ExifServiceFacade {
    if (!ExifServiceFacade.instance) {
      ExifServiceFacade.instance = new ExifServiceFacade()
    }
    return ExifServiceFacade.instance
  }

  /**
   * è§£æå®Œæ•´EXIFæ•°æ®ï¼ˆæ ‡å‡†+é¸¿è’™ï¼‰
   * @param photoUri ç…§ç‰‡URI
   * @param useCache æ˜¯å¦ä½¿ç”¨ç¼“å­˜ï¼ˆé»˜è®¤trueï¼‰
   * @returns å®Œæ•´EXIFæ•°æ®
   */
  async parseFullExif(photoUri: string, useCache: boolean = true): Promise<ExifData> {
    // æ£€æŸ¥ç¼“å­˜
    if (useCache && this.cache.has(photoUri)) {
      hilog.info(0x0021, 'EXIF', '[ExifFacade] ğŸ¯ å‘½ä¸­ç¼“å­˜:' + photoUri)
      return this.cache.get(photoUri)!
    }

    try {
      hilog.info(0x0021, 'EXIF', '[ExifFacade] å¼€å§‹è§£æEXIF:' + photoUri)
      const startTime = Date.now()

      // ä½¿ç”¨æ··åˆè§£æç­–ç•¥
      const exifData = await this.exifParser.parseExif(photoUri)

      const elapsed = Date.now() - startTime
      hilog.info(0x0021, 'EXIF', `[ExifFacade] âœ… EXIFè§£æå®Œæˆï¼Œè€—æ—¶: ${elapsed}ms`)

      // å­˜å…¥ç¼“å­˜
      if (useCache) {
        this.cache.set(photoUri, exifData)
        hilog.info(0x0021, 'EXIF', `[ExifFacade] ç¼“å­˜å·²æ›´æ–°ï¼Œå½“å‰ç¼“å­˜æ•°: ${this.cache.size()}`)
      }

      return exifData
    } catch (error) {
      hilog.error(0x0021, 'EXIF', '[ExifFacade] EXIFè§£æå¤±è´¥:' + error)
      throw new Error(`EXIFè§£æå¤±è´¥: ${error}`)
    }
  }

  /**
   * ä»…è§£æåŸºç¡€EXIFå‚æ•°ï¼ˆå¿«é€Ÿæ¨¡å¼ï¼‰
   * @param photoUri ç…§ç‰‡URI
   * @returns åŸºç¡€EXIFæ•°æ®ï¼ˆå…‰åœˆ/å¿«é—¨/ISO/ç„¦è·ï¼‰
   */
  async parseBasicExif(photoUri: string): Promise<Partial<ExifData>> {
    hilog.info(0x0021, 'EXIF', '[ExifFacade] å¿«é€Ÿæ¨¡å¼ï¼šä»…è§£æåŸºç¡€å‚æ•°')
    return await this.exifParser!.parseBasicExif(photoUri)
  }

  /**
   * æ¸…é™¤ç¼“å­˜
   */
  clearCache(): void {
    this.cache.clear()
    hilog.info(0x0021, 'EXIF', '[ExifFacade] ç¼“å­˜å·²æ¸…ç©º')
  }

  /**
   * è·å–ç¼“å­˜çŠ¶æ€
   */
  getCacheStats(): CacheStats {
    const stats: CacheStats = {
      size: this.cache.size(),
      maxSize: 50
    }
    return stats
  }
}

/**
 * ç¼“å­˜ç»Ÿè®¡æ¥å£
 */
interface CacheStats {
  size: number
  maxSize: number
}
